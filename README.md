# Design Pattern

### 创建型模式 --- 对象的创建

#### single-pattern
    单例模式
        使用简单，全局唯一，但违背了基于接口而非实现的设计原则， 也违背了广义上理解的OOP的抽象特性。
    
#### factory-pattern
    工厂模式
        工厂方法(包含简单工厂) : 常用  simple/method
        抽象工厂: 复杂，不常用, 当创建的对象维度不止一个，如：除了 json、xml之分， 还有对应系统windows、linux之分，抽象工厂可以有效减少类的个数

#### abstract-factory-pattern
    抽象工厂模式
        ↑↑↑↑↑↑↑↑↑↑
        
#### builder-pattern
    建造者模式

#### protptype-pattern 
    原型模式(并不常用)
        利用已有对象(原型)进行复制(拷贝)的方式来创建新对象
        浅克隆、深克隆

###  结构型模式  --- 类或对象的组合或组装

#### proxy-pattern
    代理模式
        不改变原始类代码的情况下，通过引入代理类来给原始类附加功能

#### bridge-pattern
    桥接模式(并不常用、难理解)
        将抽象和实现解耦，让它们可以独立变化，通过组合替代继承关系

#### decorator-pattern
    装饰器模式
        是对功能的增强，例如IO类，装饰器类和原始类继承同样的父类，这样可以对原始类嵌套多个装饰器类
    
#### adapter-pattern
    适配器模式
        将不兼容的接口转换为可兼容的接口，让接口不兼容的类可以一起工作， 两种实现方式:
        类适配器: 使用继承关系实现
        对象适配器：使用组合关系实现

#### facade-pattern
    门面模式/外观模式(并不常用)
        若子系统需调用a,b,c三个接口，那把a,b,c包裹成一个接口供系统调用 -_-

#### composite-pattern 
    组合模式(并不常用)
        应用场景: 主要是用来处理树形结构数据，所以数据必须能表示成树形结构

#### flyweight-pattern
    享元模式(并不常用)
        当存在大量相似/重复对象且为不可变对象时，可在内存中只保留一份实例，供多处代码引用

###  行为型模式 --- 类或对象之间的交互

#### observer-pattern
    观察者模式/发布订阅模式
        在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
        
#### template-pattern
    模板模式
          定义一个抽象类骨架，骨架中用到的方法默认实现或者设计成一个扩展点(抽象方法、抛出unsupportedException..), 这样就可以
       在不改变骨架的基础上，自定义扩展方法，来达到复用、扩展的目的
    回调函数(同步回调、异步回调)
       与模板模式类似，当方法运行后，运行回调方法，回调方法可自由进行扩展
    两者区别
        应用场景上，两者基本一致
        实现上，模板模式基于继承关系来实现，回调基于组合来实现，从组合优于继承考虑，回调比模板模式更加灵活
          
#### strategy-pattern
    策略模式
             工厂模式是解耦对象的创建与使用，观察者模式是解耦观察者和被观察者，而策略模式跟两者类似，也能起到解耦作用，不过，它解耦的是
        策略的定义、创建、使用这三部分，可避免冗长的if-else语句。
        
#### chainOfResponsibility-pattern
    职责链模式
        处理器形成一条链条(链表、列表)，从而使每个处理器都处理一遍 或者 当某个处理器可处理时，不继续往下传递

#### stateMachine-pattern
    状态模式(并不常用)
        常用于游戏、工作流引擎
    有限状态机
        实现方式一：分支逻辑法（充斥大量if-else、switch）
        实现方式二：查表法
        实现方式三：状态模式
    
#### iterator-pattern
    迭代器模式/游标模式
        作用：遍历数据，优势：
        一般包括容器和容器迭代器两部分内容，容器包含容器接口、容器实现类，迭代器包含迭代器接口、迭代器实现类
        for-each 是语法糖，底层也是迭代器
        优势: 
            对于复杂的数据结构，如 树、图等，有各种复杂的遍历方式， 可以把这种复杂数据结构的遍历方式拆分到迭代器类中， 从数据结构中剥离出来
            提供了抽象接口，方便以后修改和切换，符合开闭原则
            因为游标是独立的，可同时对同一容器进行不同遍历而互不影响
    注意迭代器遍历时增删元素的问题（ 就算是java的迭代器，多次调用remove也会报错, 即一次next后只能跟一次remove ), 最容器的方式是增删后再遍历的时候抛错

#### visitor-pattern
    访问者模式(并不常用、难理解)
           需要对一组继承相同父类/实现相同接口进行一系列不相关业务操作，避免不断添加功能导致类不断膨胀、职责不单一，使用访问者模式，
        将对象与操作解耦，定义在独立细分的访问者类(Extractor、Compressor)中
    双分派: 指执行哪个对象的方法，根据对象的运行时类型来决定，执行对象的哪个方法，根据方法参数的运行时类型来决定，支持双分派的语言不需要访问者模式

#### snapshot-pattern
    备忘录模式/快照模式
        主要用来防丢失、撤销、恢复等
        低频全量备份 + 高频增量备份相结合
                当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就
            先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量
            备份的数量和频率，减少对时间、内存的消耗。

#### command-pattern
    命令模式(不常用)
        将函数封装为对象，方便控制执行，主要作用是用来控制命令的执行，比如异步、延迟、排队执行、撤销重试、存储、增添日志等
        
#### interpreter-pattern
    解释器模式(不常用)
        自定义语法规则(解释器), 用于特定领域：编译器、规则引擎、正则表达式.    
        没有固定模板, 实现灵活
        
#### mediator-pattern
    中介模式(不常用)
        类似消息中间件
        将一组对象之间的交互关系，转变为一对多的关系
        好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的"上帝类"
    与观察者模式(即订阅模式)区别
        观察者模式大部分是单向的，即一个参与者要么是观察者，要么是被观察者，比较有条理，而中介模式参与者之间的交互错综复杂 
        观察者模式无法实现参与者的顺序要求，而中介模式可以引入中介类来控制先后调用
